26.5 VM and Container Configuration

When a new virtual machine or container is created, it needs to be able to connect to the outside world. Like any other computer or resource on a network, it will need a unique hostname and IP address along with proper subnet mask, DNS, and default route. Since it is desirable to have images and containers created and managed by other programs, initialization scripts are required to make changes to a base image.

The image, which is stored as a set of files and ready to use, will be lacking important information such as the correct network settings, users, groups and permissions, paths to resources such as databases and storage blocks, SSH keys, and any other configurations that would normally be done manually by a system administrator. These scripts need to be flexible and addressable by other programs in order to minimize required inputs from human operators, and also need to be secure since they may contain sensitive information like login credentials.

Fortunately, there are utilities such as cloud-init and kickstart scripts (for VMs) that can help simplify this process. These utilities can call other programs through an API, read metadata from a server, or configure instances. In Kubernetes, there are even specialized containers, called Init containers, that run before application containers start.

SSH, or secure shell, is used to communicate with and manage both VMs and containers. When a new virtual machine or container is created from an image, the administrator can use a utility like cloud-init to generate new SSH host keys. The key pair is a set of random mathematically related numbers generated by an algorithm that is used to authenticate a user (which could also be another system). Administrators can also generate key pairs manually with the ssh-keygen command. Incorrect or missing SSH keys are quite often the reason systems won’t communicate with each other even when IP addresses and hostnames are correct.

Another factor that needs to be managed is the unique id of a system, or uuid. This uuid should be generated and added to the D-Bus machine ID configuration file during installation or when first booting the VM or container. The dbus-uuidgen command can be used to generate or read a universally unique ID for a system. This ID takes the form of a 128-bit number that is unique, or at least very unlikely to be duplicated until the year 3400 A.D. The uuid must remain unchanged until a system is rebooted so that processes know what kernel they are running on. Additionally, the uuid can be used to identify any object in a cloud deployment and is often used by SQL databases and other programming languages like JavaScript and Python to identify objects.

The cloud-init utility can be used to automate initial configuration parameters on a Linux virtual machine. In addition to setting the hostname, SSH keys, and network configuration it can also set the root password, time zone, mount points, and invoke custom scripts that provide additional configurations not supported by cloud-init settings.

Other critical settings to verify to ensure virtualized products, such as VMs and containers, function properly are the virtualization extensions, which are effectively hardware support for virtualization that is built into the CPU, such as Intel’s VT-x and AMD’s AMD-V extensions. These settings can be verified on a host system in the /proc/cpuinfo file and in the system BIOS. For example, the flags in the /proc/cpuinfo file below can be used to determine if Intel’s VT-x and AMD’s AMD-V extensions are installed:

sysadmin@localhost:~$ cat /proc/cpuinfo
Output Omitted...
physical id     : 1
siblings        : 8
core id         : 0
cpu cores       : 4
apicid          : 32
initial apicid  : 32
fpu             : yes
fpu_exception   : yes
cpuid level     : 11
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca
cmov
pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdt scp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cplvmxsmx est tm2 ssse3 cx16 xtprpdcm pcid dca sse4_1 sse4_2 popcnt aes lahf_lm tpr_shadow vnmi flexpriority ept vpid dtherm ida arat
bugs            :
bogomips        : 4787.47
clflush size    : 64

In the output above, in the flags field, the lm flag means that the system has a 64-bit CPU and the vmx flag means that the Intel’s VT-x virtualization extension is enabled in the BIOS.

Consider This

To understand why virtualizations are needed, a brief explanation of CPU architecture is needed.

There are two main CPU architecture types: x86 and x64. The x86 architecture has roots that reach back to 8‐bit processors built by Intel in the late 1970s. As manufacturing capabilities improved and software demands increased, Intel extended the 8‐bit architecture to 16 bits. Later still, in 1985, Intel extended the architecture to 32 bits. The current 32-bit processor is what is known as x86. In 2003, AMD introduced a 64‐bit extension to the x86 architecture and later in 2004, Intel announced its own 64‐bit architectural extension. The current 64-bit processor is known as x64. Understanding the difference between the 32-bit and 64-bit is important because virtualization technology is compatible with 64-bit but not with 32-bit.

To check which CPU type your Linux system is using, execute the lscpu command:

sysadmin@localhost:~$ lscpu
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Output Omitted...

Finally, sometimes virtualization platforms require a guest operating system to be supported with specific drivers, called guest drivers or guest agents, that are not included in their standard distributions. Guest drivers provide additional functionality and performance such as mouse support to allow your hardware mouse to communicate with the VM, folder sharing between host and VM, automatic login settings, and time synchronization, to name a few. These drivers are necessary because the way a hypervisor communicates with physical hardware is different from how the OS would normally call hardware devices.

